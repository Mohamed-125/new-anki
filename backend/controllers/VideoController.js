const { default: axios } = require("axios");
const VideoModel = require("../models/VideoModel");
const { YoutubeTranscript } = require("youtube-transcript");
const getSubtitles = require("youtube-captions-scraper").getSubtitles;

const { Client } = require("youtubei");

// module.exports.getVideoData = async (req, res, next) => {
//   const videoId = req.params.videoId;

//   const url = `https://www.youtube.com/watch?v=${videoId}`;

//   axios
//     .get(url)
//     .then((response) => {
//       const $ = cheerio.load(response.data);
//       let title = $("title").text();
//       let thembnail = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;

//       const regex = /{[^]*}/; // This regex tries to match anything within curly braces

//       let script = $("body div + script").text().slice(29);
//       let stepOneJson = script;
//       let json = stepOneJson.match(/{.*}/)[0];

//       json = json.slice(0, json.indexOf("function") - 2);

//       res.send({
//         response: response.data,
//         url: url,
//         thembnail,
//         json,
//       });
//     })
//     .catch((err) => {
//       return res.status(400).send(err.message);
//     });
// };

module.exports.getVideoData = async (req, res, next) => {
  const videoId = req.params.videoId;
  const apiKey = process.env.YOUTUBE_API_KEY; // Store your API key securely in environment variables

  const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet,contentDetails`;
  const captionsUrl = `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&key=${apiKey}&part=snippet`;

  try {
    // Fetch Video Details
    const videoResponse = await axios.get(videoDetailsUrl);
    const videoData = videoResponse.data.items[0];
    if (!videoData) {
      return res.status(404).send("Video not found");
    }

    // Extract title, thumbnail, and description
    const title = videoData.snippet.title;
    const thumbnail = videoData.snippet.thumbnails.high.url;
    const description = videoData.snippet.description;

    // Fetch Available Captions
    const captionsResponse = await axios.get(captionsUrl);
    const captions = captionsResponse.data.items;

    // Extract details of available captions (language, name)
    const availableCaptions = captions.map((caption) => {
      return {
        id: caption.id,
        language: caption.snippet.language,
        name: caption.snippet.name || caption.snippet.language,
        isAutoGenerated: caption.snippet.trackKind === "asr",
      };
    });

    // Send response
    res.send({
      title,
      thumbnail,
      description,
      availableCaptions,
    });
  } catch (err) {
    console.error("Error fetching video data:", err.message);
    return res.status(400).send(err.message);
  }
};

const getTranscript = async (videoId, lang) => {
  console.log(videoId, lang.slice(0, 2));

  try {
    const subtitle = await getSubtitles({
      videoID: videoId, // youtube video id
      lang: lang.slice(0, 2), // default: `en`
    });
    return subtitle;
  } catch (err) {
    throw new Error(err.message);
  }
};
const { spawn } = require("child_process");

module.exports.getTranscript = async (req, res) => {
  const { videoId, lang = "en" } = req.query;

  if (!videoId) {
    return res.status(400).json({ msg: "Missing videoId parameter" });
  }

  // Construct the YouTube URL
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // Run yt-dlp as a child process to fetch subtitle URLs
  const pythonProcess = spawn("yt-dlp", [
    "--write-auto-sub", // Get auto-generated subtitles
    "--skip-download", // Don't download the video
    "--sub-lang",
    lang, // Specify subtitle language
    "-J", // Output JSON format
    videoUrl,
  ]);

  let data = "";
  let errorData = "";

  // Collect data from stdout
  pythonProcess.stdout.on("data", (chunk) => {
    data += chunk.toString();
  });

  // Collect error data from stderr
  pythonProcess.stderr.on("data", (chunk) => {
    errorData += chunk.toString();
  });

  // Handle process close
  pythonProcess.on("close", async (code) => {
    if (code === 0) {
      try {
        const jsonData = JSON.parse(data);
        const subtitles =
          jsonData.subtitles?.[lang] || jsonData.automatic_captions?.[lang];

        if (!subtitles || subtitles.length === 0) {
          return res.status(404).json({ msg: "No subtitles found" });
        }

        // Get the first valid subtitle URL (VTT format is best)
        const subtitleUrl = subtitles.find((s) => s.ext === "vtt")?.url;

        if (!subtitleUrl) {
          return res.status(404).json({ msg: "No valid subtitle URL found" });
        }

        // Fetch the subtitle content
        const subtitleResponse = await axios.get(subtitleUrl);
        const subtitleText = subtitleResponse.data;

        // Parse the VTT subtitle text
        const formattedSubtitles = parseVTT(subtitleText);

        return res.status(200).json(formattedSubtitles);
      } catch (err) {
        return res.status(500).json({
          msg: "Failed to process subtitles",
          error: err.message,
        });
      }
    } else {
      return res.status(500).json({
        msg: "yt-dlp execution failed",
        error: errorData || "Unknown error",
      });
    }
  });
};

// Function to parse WebVTT subtitle text into JSON format
function parseVTT(vttString) {
  const lines = vttString.split("\n").filter((line) => line.trim() !== "");
  const result = [];
  let currentSubtitle = { start: "", end: "", text: "" };

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];

    // Match timecode line (e.g., "00:00:03.200 --> 00:00:06.000")
    const timeMatch = line.match(
      /(\d{2}:\d{2}:\d{2}\.\d{3}) --> (\d{2}:\d{2}:\d{2}\.\d{3})/
    );

    if (timeMatch) {
      // Save previous subtitle if it exists
      if (currentSubtitle.text) {
        result.push({ ...currentSubtitle });
      }

      // Start new subtitle block
      currentSubtitle = {
        start: timeMatch[1],
        end: timeMatch[2],
        text: "",
      };
    } else {
      // Append text to the current subtitle block
      currentSubtitle.text += (currentSubtitle.text ? " " : "") + line;
    }
  }

  // Push the last subtitle block
  if (currentSubtitle.text) {
    result.push(currentSubtitle);
  }

  return result;
}

module.exports.createVideo = async (req, res, next) => {
  const {
    url,
    videoTitle: title,
    thumbnail,
    availableCaptions,
    defaultCaptionData,
    playlistId,
  } = req.body;

  if (!url) return res.status(400).send("you have to enter the video url");
  try {
    const createdVideo = await VideoModel.create({
      url,
      userId: req.user?._id,
      title,
      thumbnail,
      availableCaptions,
      defaultCaptionData,
      playlistId,
    });

    res.status(200).send(createdVideo);
  } catch (err) {
    err.message;
    res.status(400).send(err);
  }
};

module.exports.getUserVideos = async (req, res, next) => {
  try {
    const videos = await VideoModel.find(
      { userId: req.user?._id },
      {},
      { sort: { createdAt: -1 } }
    );
    res.status(200).send(videos);
  } catch (err) {
    res.status(400).send(err);
  }
};

module.exports.getVideo = async (req, res, next) => {
  try {
    const video = await VideoModel.find({ _id: req.params.id }).populate(
      "videoCards"
    );
    res.status(200).send(video[0]);
  } catch (err) {
    console.log("err", err);
    res.status(400).send(err);
  }
};

module.exports.updateVideo = async (req, res, next) => {
  const { playlistId, defaultCaptionData } = req.body;

  console.log(req.body);
  try {
    const updatedVideo = await VideoModel.findByIdAndUpdate(
      { _id: req.params.id },
      { playlistId, defaultCaptionData },
      {
        new: true,
      }
    );
    res.status(200).send(updatedVideo);
  } catch (err) {
    res.status(400).send(err);
  }
};
module.exports.deleteVideo = async (req, res, next) => {
  try {
    const deletedTodo = await VideoModel.findByIdAndDelete({
      _id: req.params.id,
    });
    res.status(200).send("deleted!!");
  } catch (err) {
    res.status(400).send(err);
  }
};

module.exports.batchDelete = async (req, res) => {
  const { ids } = req.body;
  try {
    await VideoModel.deleteMany({ _id: { $in: ids } });
    res.status(200).send({ message: "videos deleted successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error deleting videos" });
  }
};
module.exports.batchMove = async (req, res) => {
  const { ids, selectedParent } = req.body;

  try {
    await VideoModel.updateMany(
      { _id: { $in: ids } },
      { playlistId: selectedParent }
    );
    res.status(200).send({ message: "videos moved successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error moveing videos" });
  }
};
