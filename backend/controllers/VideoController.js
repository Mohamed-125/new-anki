const VideoModel = require("../models/VideoModel");

// const { Client } = require("youtubei");

// module.exports.getVideoData = async (req, res, next) => {
//   const videoId = req.params.videoId;

//   const url = `https://www.youtube.com/watch?v=${videoId}`;

//   axios
//     .get(url)
//     .then((response) => {
//       const $ = cheerio.load(response.data);
//       let title = $("title").text();
//       let thembnail = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;

//       const regex = /{[^]*}/; // This regex tries to match anything within curly braces

//       let script = $("body div + script").text().slice(29);
//       let stepOneJson = script;
//       let json = stepOneJson.match(/{.*}/)[0];

//       json = json.slice(0, json.indexOf("function") - 2);

//       res.send({
//         response: response.data,
//         url: url,
//         thembnail,
//         json,
//       });
//     })
//     .catch((err) => {
//       return res.status(400).send(err.message);
//     });
// };

// module.exports.getVideoData = async (req, res, next) => {
//   const videoId = req.params.videoId;
//   const apiKey = process.env.YOUTUBE_API_KEY; // Store your API key securely in environment variables

//   const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet,contentDetails`;
//   const captionsUrl = `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&key=${apiKey}&part=snippet`;

//   try {
//     // Fetch Video Details
//     const videoResponse = await axios.get(videoDetailsUrl);
//     const videoData = videoResponse.data.items[0];
//     if (!videoData) {
//       return res.status(404).send("Video not found");
//     }

//     // Extract title, thumbnail, and description
//     const title = videoData.snippet.title;
//     const thumbnail = videoData.snippet.thumbnails.high.url;
//     const description = videoData.snippet.description;

//     // Fetch Available Captions
//     const captionsResponse = await axios.get(captionsUrl);
//     const captions = captionsResponse.data.items;

//     // Extract details of available captions (language, name)
//     const availableCaptions = captions.map((caption) => {
//       return {
//         id: caption.id,
//         language: caption.snippet.language,
//         name: caption.snippet.name || caption.snippet.language,
//         isAutoGenerated: caption.snippet.trackKind === "asr",
//       };
//     });

//     // Send response
//     res.send({
//       title,
//       thumbnail,
//       description,
//       availableCaptions,
//     });
//   } catch (err) {
//     console.error("Error fetching video data:", err.message);
//     return res.status(400).send(err.message);
//   }
// };

// const getTranscript = async (videoId, lang) => {
//   console.log(videoId, lang.slice(0, 2));

//   try {
//     const subtitle = await getSubtitles({
//       videoID: videoId, // youtube video id
//       lang: lang.slice(0, 2), // default: `en`
//     });
//     return subtitle;
//   } catch (err) {
//     throw new Error(err.message);
//   }
// };
// module.exports.getTranscript = async (req, res) => {
//   const youtube = new Client();

//   const { videoId, lang } = req.query;

//   if (!videoId) {
//     return res.status(300).send("there is not video id");
//   }
//   try {
//     const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
//       lang,
//     });

//     console.log("transcript", transcript);
//     const newArray = transcript.map((caption) => ({
//       dur: caption.duration,
//       start: caption.start,
//       text: caption.text,
//     }));

//     // Update CORS headers
//     res.set({
//       "Access-Control-Allow-Origin": req.headers.origin || "*",
//       "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
//       "Access-Control-Allow-Headers": "Content-Type, Authorization",
//       "Access-Control-Allow-Credentials": "true",
//     });

//     return res.status(200).json(newArray);
//   } catch (err) {
//     console.log("err", err);
//     // Set CORS headers even for error responses
//     res.set({
//       "Access-Control-Allow-Origin": req.headers.origin || "*",
//       "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
//       "Access-Control-Allow-Headers": "Content-Type, Authorization",
//       "Access-Control-Allow-Credentials": "true",
//     });
//     return res.status(400).json({
//       msg: "Error getting the subtitle",
//       error: err.message,
//       query: res.query,
//     });
//   }
// };
const UserVideosModel = require("../models/UserVideosModel").default;

module.exports.createVideo = async (req, res, next) => {
  try {
    // Create the video
    const createdVideo = await VideoModel.create({
      ...req.body,
      userId: req?.user?._id,
    });

    // Create user-video association
    await UserVideosModel.create({
      userId: req?.user?._id,
      videoId: createdVideo._id,
      playlistId: req.body.playlistId || null,
    });

    res.set({
      "Access-Control-Allow-Origin": req.headers.origin || "*",
      "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Credentials": "true",
    });

    res.status(200).send(createdVideo);
  } catch (err) {
    console.log("err", err);
    res.set({
      "Access-Control-Allow-Origin": req.headers.origin || "*",
      "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Credentials": "true",
    });
    res.status(400).send(err);
  }
};
module.exports.getUserVideos = async (req, res, next) => {
  const { page: pageNumber, searchQuery, playlistId, language } = req.query;
  const limit = 5;
  let page = +pageNumber || 0;

  try {
    // Get user's video associations
    const userVideoQuery = { userId: req.user._id };
    if (playlistId) {
      userVideoQuery.playlistId = playlistId;
    }

    const userVideos = await UserVideosModel.find(userVideoQuery)
      .sort({ addedAt: -1 })
      .skip(page * limit)
      .limit(limit)
      .lean();

    const videoIds = userVideos.map((uv) => uv.videoId);

    // Get the actual videos
    let videoQuery = {
      _id: { $in: videoIds },
    };

    if (searchQuery) {
      videoQuery.title = { $regex: searchQuery, $options: "i" };
    }

    console.log("videoQuery", videoQuery);

    const videosCount = await VideoModel.countDocuments(videoQuery);
    const remaining = Math.max(0, videosCount - limit * (page + 1));
    const nextPage = remaining > 0 ? page + 1 : null;

    const videos = await VideoModel.find(videoQuery, {
      defaultCaptionData: 0,
    }).lean();

    // Sort videos in the same order as userVideos
    const sortedVideos = videoIds
      .map((id) => videos.find((v) => v._id.toString() === id.toString()))
      .filter(Boolean);

    res.status(200).send({ videos: sortedVideos, nextPage, videosCount });
  } catch (err) {
    console.log(err);
    res.status(400).send(err);
  }
};
module.exports.getVideo = async (req, res, next) => {
  try {
    const video = await VideoModel.find({ _id: req.params.id }).populate(
      "videoCards"
    );
    res.status(200).send(video[0]);
  } catch (err) {
    console.log("err", err);
    res.status(400).send(err);
  }
};

module.exports.updateVideo = async (req, res, next) => {
  try {
    const updatedVideo = await VideoModel.findByIdAndUpdate(
      { _id: req.params.id },
      req.body,
      {
        new: true,
      }
    );
    res.status(200).send(updatedVideo);
  } catch (err) {
    res.status(400).send(err);
  }
};
module.exports.deleteVideo = async (req, res, next) => {
  try {
    const video = await VideoModel.findById(req.params.id);
    if (!video) {
      return res.status(404).send("Video not found");
    }

    // Only delete the video if the user is the owner
    if (video.userId?.toString() === req.user._id?.toString()) {
      await VideoModel.findByIdAndDelete(req.params.id);
    }

    // Always delete the user's association with the video
    await UserVideosModel.deleteOne({
      userId: req.user._id,
      videoId: req.params.id,
    });

    res.status(200).send("Video removed successfully");
  } catch (err) {
    console.log("error deleting the video", err);
    res.status(400).send(err);
  }
};

module.exports.batchDelete = async (req, res) => {
  const { ids } = req.body;
  try {
    // Get videos owned by the user
    const videos = await VideoModel.find({
      _id: { $in: ids },
      userId: req.user._id,
    });

    const ownedVideoIds = videos.map((v) => v._id);

    // Delete owned videos
    if (ownedVideoIds.length > 0) {
      await VideoModel.deleteMany({ _id: { $in: ownedVideoIds } });
    }

    // Delete all user-video associations
    await UserVideosModel.deleteMany({
      userId: req.user._id,
      videoId: { $in: ids },
    });

    res.status(200).send({ message: "Videos removed successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error removing videos" });
  }
};
module.exports.batchMove = async (req, res) => {
  const { ids, selectedParent } = req.body;

  try {
    // Update user-video associations with new playlist
    await UserVideosModel.updateMany(
      {
        userId: req.user._id,
        videoId: { $in: ids },
      },
      { playlistId: selectedParent }
    );

    res.status(200).send({ message: "Videos moved successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error moving videos" });
  }
};
module.exports.shareVideo = async (req, res) => {
  try {
    const video = await VideoModel.findById(req.params.id);
    if (!video) {
      return res.status(404).send("Video not found");
    }

    // Check if user already has this video
    const existingUserVideo = await UserVideosModel.findOne({
      userId: req.user._id,
      videoId: video._id,
    });

    if (existingUserVideo) {
      return res.status(400).send("Video already in your library");
    }

    // Create user-video association
    const userVideo = await UserVideosModel.create({
      userId: req.user._id,
      videoId: video._id,
      playlistId: req.body.playlistId || null,
    });

    res.status(200).send({ message: "Video shared successfully", userVideo });
  } catch (err) {
    res.status(400).send(err);
  }
};
