const VideoModel = require("../models/VideoModel");

// const { Client } = require("youtubei");

// module.exports.getVideoData = async (req, res, next) => {
//   const videoId = req.params.videoId;

//   const url = `https://www.youtube.com/watch?v=${videoId}`;

//   axios
//     .get(url)
//     .then((response) => {
//       const $ = cheerio.load(response.data);
//       let title = $("title").text();
//       let thembnail = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;

//       const regex = /{[^]*}/; // This regex tries to match anything within curly braces

//       let script = $("body div + script").text().slice(29);
//       let stepOneJson = script;
//       let json = stepOneJson.match(/{.*}/)[0];

//       json = json.slice(0, json.indexOf("function") - 2);

//       res.send({
//         response: response.data,
//         url: url,
//         thembnail,
//         json,
//       });
//     })
//     .catch((err) => {
//       return res.status(400).send(err.message);
//     });
// };

// module.exports.getVideoData = async (req, res, next) => {
//   const videoId = req.params.videoId;
//   const apiKey = process.env.YOUTUBE_API_KEY; // Store your API key securely in environment variables

//   const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet,contentDetails`;
//   const captionsUrl = `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&key=${apiKey}&part=snippet`;

//   try {
//     // Fetch Video Details
//     const videoResponse = await axios.get(videoDetailsUrl);
//     const videoData = videoResponse.data.items[0];
//     if (!videoData) {
//       return res.status(404).send("Video not found");
//     }

//     // Extract title, thumbnail, and description
//     const title = videoData.snippet.title;
//     const thumbnail = videoData.snippet.thumbnails.high.url;
//     const description = videoData.snippet.description;

//     // Fetch Available Captions
//     const captionsResponse = await axios.get(captionsUrl);
//     const captions = captionsResponse.data.items;

//     // Extract details of available captions (language, name)
//     const availableCaptions = captions.map((caption) => {
//       return {
//         id: caption.id,
//         language: caption.snippet.language,
//         name: caption.snippet.name || caption.snippet.language,
//         isAutoGenerated: caption.snippet.trackKind === "asr",
//       };
//     });

//     // Send response
//     res.send({
//       title,
//       thumbnail,
//       description,
//       availableCaptions,
//     });
//   } catch (err) {
//     console.error("Error fetching video data:", err.message);
//     return res.status(400).send(err.message);
//   }
// };

// const getTranscript = async (videoId, lang) => {
//   console.log(videoId, lang.slice(0, 2));

//   try {
//     const subtitle = await getSubtitles({
//       videoID: videoId, // youtube video id
//       lang: lang.slice(0, 2), // default: `en`
//     });
//     return subtitle;
//   } catch (err) {
//     throw new Error(err.message);
//   }
// };
// module.exports.getTranscript = async (req, res) => {
//   const youtube = new Client();

//   const { videoId, lang } = req.query;

//   if (!videoId) {
//     return res.status(300).send("there is not video id");
//   }
//   try {
//     const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
//       lang,
//     });

//     console.log("transcript", transcript);
//     const newArray = transcript.map((caption) => ({
//       dur: caption.duration,
//       start: caption.start,
//       text: caption.text,
//     }));

//     // Update CORS headers
//     res.set({
//       "Access-Control-Allow-Origin": req.headers.origin || "*",
//       "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
//       "Access-Control-Allow-Headers": "Content-Type, Authorization",
//       "Access-Control-Allow-Credentials": "true",
//     });

//     return res.status(200).json(newArray);
//   } catch (err) {
//     console.log("err", err);
//     // Set CORS headers even for error responses
//     res.set({
//       "Access-Control-Allow-Origin": req.headers.origin || "*",
//       "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
//       "Access-Control-Allow-Headers": "Content-Type, Authorization",
//       "Access-Control-Allow-Credentials": "true",
//     });
//     return res.status(400).json({
//       msg: "Error getting the subtitle",
//       error: err.message,
//       query: res.query,
//     });
//   }
// };
module.exports.createVideo = async (req, res, next) => {
  try {
    const createdVideo = await VideoModel.create({
      ...req.body,
      userId: req?.user?._id,
    });

    res.set({
      "Access-Control-Allow-Origin": req.headers.origin || "*",
      "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Credentials": "true",
    });

    res.status(200).send(createdVideo);
  } catch (err) {
    console.log("err", err);
    res.set({
      "Access-Control-Allow-Origin": req.headers.origin || "*",
      "Access-Control-Allow-Methods": "GET, PUT, POST, DELETE, HEAD, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Credentials": "true",
    });
    res.status(400).send(err);
  }
};
module.exports.getUserVideos = async (req, res, next) => {
  const { page: pageNumber, searchQuery, playlistId, language } = req.query;
  const limit = 5;
  let page = +pageNumber || 0;

  try {
    const query = { userId: req.user._id };
    if (searchQuery) {
      query.title = { $regex: searchQuery, $options: "i" };
    }
    if (playlistId) {
      query.playlistId = playlistId;
    }
    // if (language) {
    //   query.language = language;
    // }
    const videosCount = await VideoModel.countDocuments(query);

    const skipNumber = page * limit;
    const remaining = Math.max(0, videosCount - limit * (page + 1));
    const nextPage = remaining > 0 ? page + 1 : null;

    const videos = await VideoModel.find(
      query,
      { defaultCaptionData: 0 },
      { sort: { createdAt: -1 } }
    )
      .skip(skipNumber)
      .limit(limit);

    res.status(200).send({ videos, nextPage, videosCount });
  } catch (err) {
    console.log(err);
    res.status(400).send(err);
  }
};
module.exports.getVideo = async (req, res, next) => {
  try {
    const video = await VideoModel.find({ _id: req.params.id }).populate(
      "videoCards"
    );
    res.status(200).send(video[0]);
  } catch (err) {
    console.log("err", err);
    res.status(400).send(err);
  }
};

module.exports.updateVideo = async (req, res, next) => {
  const { playlistId, defaultCaptionData } = req.body;

  console.log(req.body);
  try {
    const updatedVideo = await VideoModel.findByIdAndUpdate(
      { _id: req.params.id },
      { playlistId, defaultCaptionData },
      {
        new: true,
      }
    );
    res.status(200).send(updatedVideo);
  } catch (err) {
    res.status(400).send(err);
  }
};
module.exports.deleteVideo = async (req, res, next) => {
  try {
    const deletedTodo = await VideoModel.findByIdAndDelete({
      _id: req.params.id,
    });
    res.status(200).send("deleted!!");
  } catch (err) {
    res.status(400).send(err);
  }
};

module.exports.batchDelete = async (req, res) => {
  const { ids } = req.body;
  try {
    await VideoModel.deleteMany({ _id: { $in: ids } });
    res.status(200).send({ message: "videos deleted successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error deleting videos" });
  }
};
module.exports.batchMove = async (req, res) => {
  const { ids, selectedParent } = req.body;

  try {
    await VideoModel.updateMany(
      { _id: { $in: ids } },
      { playlistId: selectedParent }
    );
    res.status(200).send({ message: "videos moved successfully" });
  } catch (error) {
    res.status(500).send({ error: "Error moveing videos" });
  }
};
module.exports.forkVideo = async (req, res) => {
  try {
    const originalVideo = await VideoModel.findOne({
      _id: req.params.id,
    }).lean();
    if (!originalVideo) {
      return res.status(404).send("Video not found");
    }

    if (originalVideo?.topicId) delete originalVideo?.topicId;

    const forkedVideo = await VideoModel.create({
      userId: req.user?._id,
      ...originalVideo,
    });

    res.status(200).send(forkedVideo);
  } catch (err) {
    res.status(400).send(err);
  }
};
